<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HandlerThread</title>
    <url>/2020/11/22/HandlerThread/</url>
    <content><![CDATA[<p>#HandleThread 源码阅读</p>
<p>###首先看一下成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mPriority; <span class="comment">//线程优先级</span></span><br><span class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>; <span class="comment">//线程id</span></span><br><span class="line">    Looper mLooper; <span class="comment">//持有一个Looper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Handler mHandler;  <span class="comment">//一个共享的handler，提供一个get方法可以获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###接下来看一下构造方法<br>简单的设定了优先级属性，并调用了java父类<code>Thread</code>的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a HandlerThread.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> priority The priority to run the thread at. The value supplied must be from </span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> android.os.Process&#125; and not from java.lang.Thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    mPriority = priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HandlerThread重写了父类的run方法并在run中开启一个loop</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTid = Process.myTid(); <span class="comment">//获取线程id</span></span><br><span class="line">    Looper.prepare(); <span class="comment">//调用Looper的prepare();</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mLooper = Looper.myLooper(); </span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    Process.setThreadPriority(mPriority);</span><br><span class="line">    onLooperPrepared();</span><br><span class="line">    Looper.loop();</span><br><span class="line">    mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###接着看一下<code>Looper</code><br>在Looper的类描述中有写到，线程默认是没有消息循环与其绑定的，需要创建一个，就调用<code>prepare()</code>，<code>preoare()</code>的方法描述为:将当前线程初始化为一个looper,确保在调研<code>prepare()</code>方法后调用<code>loop()</code>，并且停止loop时调用<code>quit()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类<code>Looper</code>的<code>prepare()</code>最终调用了其私有构造方法并将其设定到,<code>ThreadLocal</code>中,<code>ThreadLocal</code>将创造一个线程独立的共享变量，保证各个线程的变量相互独立。直觉来说<code>HandlerThread</code>应该有只属于自己的<code>Looper</code>,构造方法如下  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法中，<code>Looper</code>初始化了消息队列<code>mQueue</code>，并且对成员变量<code>mThread</code>进行赋值。</p>
<p>####回到<code>HandlerThread</code>的<code>run()</code><br>接着这里设定了成员变量<code>mLooper</code>并通知等待<code>Looper</code>的线程可以争用锁了<br>接下来设定线程的优先级，调用预留方法<code>onLooperPrepared()</code>这个方法可以继承用来在轮训开始前做一些事情。<br>紧接着调用了<code>Looper.loop()</code>，此时轮训正式开始了。</p>
<p>####来看一下<code>Looper.loop()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper(); <span class="comment">//获得sThreadLocal中的looper</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123; <span class="comment">//为空则说明在loop()前没有调用prepare()</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue; <span class="comment">//获取当前Looper的消息队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">    <span class="comment">// adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start'</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride =</span><br><span class="line">            SystemProperties.getInt(<span class="string">"log.looper."</span></span><br><span class="line">                    + Process.myUid() + <span class="string">"."</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">".slow"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">//进入循环</span></span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block 从消息队列中取消息 可能被阻断</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="comment">//无消息说吗消息队列正在退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Make sure the observer won't change while processing a transaction.</span></span><br><span class="line">        <span class="keyword">final</span> Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">        <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">        <span class="keyword">long</span> slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">        <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">            slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDelivery = (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDispatch = (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line">        Object token = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            token = observer.messageDispatchStarting();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);<span class="comment">//将消息发送给target处理</span></span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                observer.messageDispatched(token, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Drained"</span>);</span><br><span class="line">                    slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">"delivery"</span>,</span><br><span class="line">                        msg)) &#123;</span><br><span class="line">                    <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                    slowDeliveryDetected = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">"dispatch"</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大体思路为循环从MessageQueue中取消息，并且分发到需要接收的类，其余是一些日志打印的代码，这里有<code>Message msg = queue.next()</code><br>和<code>msg.recycleUnchecked()</code>很关键，将在<code>MessageQueue</code>对应的文章中介绍。</p>
<p>在<code>loop（）</code>方法之后，跟随<code>mTid = -1</code>意味着轮训退出时线程就走向结束了。</p>
<p>####接下来看一下<code>HandlerThread</code>的两个退出方法</p>
<ul>
<li><p>将轮训停止，不再处理任何消息  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        looper.quit();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当所有已经准备被发送处理的消息被处理后停止轮训，队列中存在的将在未来处理的消息将不再被发送。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        looper.quitSafely();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上述的两个方法最终都调用了<code>Looper</code>中的同名方法，看一下<code>Looper</code>的两个方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Looper</code>中上述两个方法都调用了<code>MessageQueue</code>的<code>quit(boolean safe)</code>方法，此时结合上面<code>loop()</code>方法，可以预想到<code>MessageQueue</code>的<code>quit(boolean safe)</code>方法调用后清空了消息队列，最终使得<code>MessageQueue</code>的<code>next()</code>方法返回<code>null</code><br>导致<code>loop()</code>在无限制for循环中<code>return</code>跳出循环执行完毕，最终导致<code>HandlerThread</code>的<code>run</code>执行完毕,自此<code>HandlerThread</code>的生命周期结束。</p>
]]></content>
      <tags>
        <tag>Android,SourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title>AOSP下载及编译</title>
    <url>/2020/05/10/asop1/</url>
    <content><![CDATA[<h1 id="AOSP下载及编译"><a href="#AOSP下载及编译" class="headerlink" title="AOSP下载及编译"></a>AOSP下载及编译</h1><h2 id="官方方案"><a href="#官方方案" class="headerlink" title="官方方案"></a>官方方案</h2><h5 id="安装Repo"><a href="#安装Repo" class="headerlink" title="安装Repo"></a>安装Repo</h5><p>1.首先确保你的主目录下有一个<code>bin/</code>文件夹,并且包含在你的路径中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir ~&#x2F;bin</span><br><span class="line">PATH&#x3D;~&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<p>2.下载Repo启动器，并且设置其为可执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;storage.googleapis.com&#x2F;git-repo-downloads&#x2F;repo &gt; ~&#x2F;bin&#x2F;repo</span><br><span class="line">chmod a+x ~&#x2F;bin&#x2F;repo</span><br></pre></td></tr></table></figure>
<p>通过这个地址下载的Repo适用于装有Python3.6及更高的系统，如果系统只有python2，可以使用下列地址下载支持Python2.7的Repo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;storage.googleapis.com&#x2F;git-repo-downloads&#x2F;repo-1 &gt; ~&#x2F;bin&#x2F;repo</span><br><span class="line">chmod a+x ~&#x2F;bin&#x2F;repo</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h5 id="初始化Repo客户端"><a href="#初始化Repo客户端" class="headerlink" title="初始化Repo客户端"></a>初始化Repo客户端</h5><p>1.创建一个空目录来存放AOSP项目，对于MacOS需要创建一块区分大小写的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir WORKING_DIRECTORY</span><br><span class="line">cd WORKING_DIRECTORY</span><br></pre></td></tr></table></figure>
<p>2.使用绑定了Google账号的邮箱地址配置Git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>3.在工作目录下运行<code>repo init</code>获得最新版本的Repo,需要为清单指定一个网址，该<code>manifest</code>用于指定Android源代码中的各个代码库应该位于工作目录的存放位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repo init -u https:&#x2F;&#x2F;android.googlesource.com&#x2F;platform&#x2F;manifest</span><br></pre></td></tr></table></figure>
<p>可以使用<code>-b</code>指定特定的分支，分支列表请参考官网<a href="https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds" target="_blank" rel="noopener">https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds</a><br>初始化成功后，你应该在工作目录下看到一个.repo目录，里面存放清单文件。  </p>
<h5 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h5><p>接下来运行<code>repo sync</code>下载源代码  </p>
<h2 id="国内用户方案"><a href="#国内用户方案" class="headerlink" title="国内用户方案"></a>国内用户方案</h2><p>对于国内的用户来说，由于源码非常大上述方法基本是不可行的。此时推荐使用  <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp" target="_blank" rel="noopener">科大镜像</a>或者<a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/?C=M&O=A" target="_blank" rel="noopener">清华镜像</a>，具体的使用方法连接里面有我就不再赘述.</p>
<h1 id="AOSP的编译"><a href="#AOSP的编译" class="headerlink" title="AOSP的编译"></a>AOSP的编译</h1><ul>
<li><p>首先 source一下AOSP目录下的envsetup.sh 之后可以通过脚本中的方法进行操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source AOSP_Path&#x2F;build&#x2F;envsetup.sh</span><br></pre></td></tr></table></figure></li>
<li><p>然后使用<code>lunch</code>选择需要编译的目标，在命令行输入（需要切换到管理员）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lunch</span><br></pre></td></tr></table></figure>
<p>然后会出现一个版本列表，选择需要的版本输入对应编号即可，<code>aosp_arm-eng</code>表示针对模拟器进行完整编译，并启用所有调试功能  </p>
</li>
<li><p>编译代码<br>使用<code>m</code>编译所有内容，可以使用<code>-jN</code>参数指定<code>N</code>为并行处理任务数。如果你没有提供<code>-j</code>参数编译系统将自动选择最合适的并行任务数</p>
</li>
</ul>
<h1 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h1><h3 id="Mac环境问题"><a href="#Mac环境问题" class="headerlink" title="Mac环境问题"></a>Mac环境问题</h3><p>1.安装Xcode命令行工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
<p>2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install git gnupg2</span><br></pre></td></tr></table></figure>
<p>3.设置文件描述符上限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># set the number of open files to be 1024</span><br><span class="line">ulimit -S -n 1024</span><br></pre></td></tr></table></figure>
<p>我的mac在设置为1024后依然出现打开文件超过上限的问题，所以设成了2048  </p>
<p>4.创建磁盘印象用于存放AOSP  </p>
<blockquote>
<p>首先,使用<code>磁盘工具-&gt;文件-&gt;映像-&gt;新建空白印象</code>其中格式选择<code>Mac OS扩展(区分大小写，日志式)</code>如果需要完整编译整个AOSP大小选择<code>250G</code>目前最新的实测<code>200G</code>不够.  </p>
</blockquote>
<p>可以通过在<code>.bashrc</code>或者<code>.zshrc</code>中加入方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mount the android file image</span><br><span class="line">mountAndroid() &#123; </span><br><span class="line">  hdiutil attach ~&#x2F;Documents&#x2F;AOSP.dmg -mountpoint &#x2F;Volumes&#x2F;AOSP; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># unmount the android file image</span><br><span class="line">umountAndroid() &#123;</span><br><span class="line"> hdiutil detach &#x2F;Volumes&#x2F;AOSP; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方便快速载入映像</p>
<h3 id="编译出现文件缺失或者module找不到的问题"><a href="#编译出现文件缺失或者module找不到的问题" class="headerlink" title="编译出现文件缺失或者module找不到的问题"></a>编译出现文件缺失或者module找不到的问题</h3><p>可能是下载不全导致。<a href="https://cs.android.com" target="_blank" rel="noopener">https://cs.android.com</a>可在此网站找到缺失的文件位置，然后前往<a href="https://android.googlesource.com/?format=HTML" target="_blank" rel="noopener">https://android.googlesource.com/?format=HTML</a>找到对应的文件进行下载。<a href="https://pan.baidu.com/s/1xIYQKBGL4xk4qq0wu7ZbDw" target="_blank" rel="noopener">这里</a>有我上传的<code>prebuilt/tool</code>的压缩包,  密码:15x5。</p>
]]></content>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title>从今天起我的个人博客建立了</title>
    <url>/2020/04/30/first/</url>
    <content><![CDATA[<h1 id="问自己的一些问题"><a href="#问自己的一些问题" class="headerlink" title="问自己的一些问题"></a><center>问自己的一些问题</center></h1><h2 id="为什么建立自己的博客"><a href="#为什么建立自己的博客" class="headerlink" title="为什么建立自己的博客?"></a>为什么建立自己的博客?</h2><blockquote>
<p>俗话说得好，一个不会写博客的程序员不是好的程序员。 首先，可以通过博客让大家了解自己，提升自己在行业内的知名度。 其次书写博客是为了给自己的学习留下痕迹，在对自己所学进行梳理的同时，如果能给别人带来一些启发那就更好了。  </p>
</blockquote>
<h2 id="为什么选择比奇堡这个名字"><a href="#为什么选择比奇堡这个名字" class="headerlink" title="为什么选择比奇堡这个名字?"></a>为什么选择比奇堡这个名字?</h2><blockquote>
<p>海绵宝宝所居住的这个比奇堡，是个快乐的地方，希望自己的博客具有足够的质量可以帮助大家解决问题、消除烦恼，也希望可以通过更加轻松愉快的表达把技术问题变得不那么枯燥。</p>
</blockquote>
<h2 id="为什么选择蟹老板作为头像？"><a href="#为什么选择蟹老板作为头像？" class="headerlink" title="为什么选择蟹老板作为头像？"></a>为什么选择蟹老板作为头像？</h2><blockquote>
<p>因为我和蟹老板一样热爱💰。蟹老板对女儿的爱，可以让他放弃自己热爱的金钱。希望自己在挣钱的同时不要忘记给家人足够的爱与陪伴。</p>
</blockquote>
]]></content>
      <tags>
        <tag>第一篇文章</tag>
      </tags>
  </entry>
</search>
